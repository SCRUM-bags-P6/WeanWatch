 /*
 * This Java source file was generated by the Gradle 'init' task.
 */
package WeanWatch;

import java.awt.Dimension;

import WeanWatch.controller.LoginCtrl;
import WeanWatch.controller.RootCtrl;
import WeanWatch.model.Event;
import WeanWatch.model.EventDetectorThread;
import WeanWatch.model.EventHandler;
import WeanWatch.model.DetectionAlgorithm;
import WeanWatch.model.Indicator;
import WeanWatch.model.IndicatorAlgorithm;
import WeanWatch.model.PDMSConn;
import WeanWatch.model.PatientHandler;
import WeanWatch.model.Personnel;
import WeanWatch.model.TimeInterval;
import WeanWatch.model.Event.Severity;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import java.io.IOException;
import java.io.Serializable;
import java.lang.invoke.SerializedLambda;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.function.Predicate;

import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;


public class App extends Application {

    // Store the primary scene
    private Stage weanStage;

    public static void main(String[] args) {
        // Start loading the patients form the PDMS
        PatientHandler.getInstance().getPatients();
        // Launch JavaFX
        launch(args); 
    }



    public void getDateForEventExample() {
        Dataset<Row> patientData = PatientHandler.getInstance().getPatients()[0].getData();
        System.out.println("Showing first 20 of all data: ");
        patientData.show();

        LocalDateTime newestTime = LocalDateTime.of(2021, 05, 16, 23, 00, 00);
        LocalDateTime oldestTime = LocalDateTime.of(2021, 05, 17, 23, 00, 00);

		//Henter timestamp fra stud1.csv første kolonne. Tjekker om timestamp er mellem de to createde LocalDateTime's 
        System.out.println("Filtering for dates...");
        Dataset<Row> eventData = patientData.filter((Row row) -> {    
            LocalDateTime localDateTime = LocalDateTime.parse(row.getString(0));
            if(localDateTime.isAfter(newestTime) && localDateTime.isBefore(oldestTime)){
                return true;
            } else {
                return false;
            }
        });

        System.out.println("Showing first 20 of filtered data: ");
        eventData.show();
    }

    public void perdicateOnDataExample() {
		//Henter data for første patient i patienthandler
        Dataset<Row> patientData = PatientHandler.getInstance().getPatients()[0].getData();

        String paramName = "SpO2";

        Double paramValue = 0.9D;
        // Define test

		//Kører en predicatetest. Sammenligner paramValue med den værdi der ligger i "SpO2" kolonnen i vores Row.
		//Returner true hvis SpO2 er mindre end paramValue.
        Predicate<Row> noiceTest = (Predicate<Row>)(Row x) -> {
            int compareResult = Double.compare(x.getDouble(x.fieldIndex(paramName)), paramValue);
            if (compareResult == 0) {
                //System.out.println("SpO2 at 0.9");
                return false;
            } else if (compareResult < 0) {
                System.out.println("SpO2 above 0.9");
                return false;
            } else {
                //System.out.println("SpO2 below 0.9");
                return true;
            }
        };
        
        System.out.println("Performing test on data: ");
        performTestOnData(patientData, noiceTest);
    }

    public static int trueCount = 0;
    public static boolean lastWasTrue = false;


	
    public void performTestOnData(Dataset<Row> patientData, Predicate<Row> test) {
		//Hver row i patientData testes. Hvis conditions er opfyldt, returner predicate true.
        patientData.foreach((Row x) -> {
            boolean testResult = test.test(x);
            if (testResult) {
                // Increment true count
                trueCount++;
                // Mark this occurrence as true
                lastWasTrue = true;
            } else { //Køres kun hvis conditions ikke længere er opfyldt
                if (lastWasTrue) {
                    // Printout
                    System.out.println("Test no longer true. Number of consequetive trues: " + trueCount);
                    // Reset
                    trueCount = 0;
                    lastWasTrue = false;
                }
            }
        });
    }

    public void testUsingIndicatorAlgorithm() {
        Dataset<Row> patientData = PatientHandler.getInstance().getPatients()[0].getData();

        // Define indicators
        ArrayList<Indicator> indicators = new ArrayList<Indicator>();

        //Ny indicator laves og lægges i ArrayList'en
		//Hver indicator's constructor kræver en Predicate. Predicate er et functional interface, der indeholder test() metoden.
		//Test() funktionen for hver predicate defineres med en lambda funktion.
        indicators.add(new Indicator(250, (Predicate<Row> & Serializable)(Row x) -> {
            return Double.compare(x.getDouble(x.fieldIndex("PEEPSet")), 12D) == 0; 
        }));

                
        indicators.add(new Indicator(250, (Predicate<Row> & Serializable)(Row x) -> {
            return Double.compare(x.getDouble(x.fieldIndex("SpO2")), 0.9D) > 0; 
        }));

		



        // indicators.add(new Indicator(30, (Predicate<Row> & Serializable)(Row x) -> {
        //     int compareResult = Double.compare(x.getDouble(x.fieldIndex("SpO2")), 0.8D);
        //     if (compareResult == 0) {
        //         //System.out.println("SpO2 at 0.9");
        //         return false;
        //     } else if (compareResult < 0) {
        //         //System.out.println("SpO2 above 0.9");
        //         return false;
        //     } else {
        //         //System.out.println("SpO2 below 0.9");
        //         return true;
        //     }
        // }));

        // indicators.add(new Indicator(30, (Predicate<Row> & Serializable)(Row x) -> {
        //     int compareResult = Double.compare(x.getDouble(x.fieldIndex("SvO2")), 0.9D);
        //     if (compareResult == 0) {
        //         //System.out.println("SpO2 at 0.9");
        //         return false;
        //     } else if (compareResult < 0) {
        //         //System.out.println("SpO2 above 0.9");
        //         return false;
        //     } else {
        //         //System.out.println("SpO2 below 0.9");
        //         return true;
        //     }
        // }));

        // Define a indicator algorithm
        DetectionAlgorithm algo = new IndicatorAlgorithm(indicators);

	
        
        patientData.foreach((Row x) -> {
            TimeInterval output = algo.evaluate(x);
            if (output != null) {
                System.out.println("A event was detected!");
            }
        });


    }




    @Override
    public void start(Stage primaryStage) throws Exception {

        //getDateForEventExample();

        //perdicateOnDataExample();

        //testUsingIndicatorAlgorithm();

		// Define indicators
		ArrayList<Indicator> indicators = new ArrayList<Indicator>();

		indicators.add(new Indicator(150, (Predicate<Row> & Serializable)(Row x) -> {
            return Double.compare(x.getDouble(x.fieldIndex("PEEPSet")), 12D) == 0; 
        }));

                
        indicators.add(new Indicator(150, (Predicate<Row> & Serializable)(Row x) -> {
            return Double.compare(x.getDouble(x.fieldIndex("SpO2")), 0.9D) > 0; 
        }));
		

		DetectionAlgorithm algo = new IndicatorAlgorithm(indicators);

		// Create Event from indicator algorithm, add to EventHandler
		EventHandler eventHandler = EventHandler.getInstance();
		//EventHandler.addEventAlgo("Rigor Mortis", "Hvis patienten har dette her, er det nok på tide at ekstubere", Severity.SEVERE, algo);



		//Instantierer vores thread
		EventDetectorThread detectorGadget = EventDetectorThread.getInstance();
		//Initialiserer threaden og kører dens run() metode
		detectorGadget.initialize();
		detectorGadget.start();

		


        // Store the primary stage
        this.weanStage = primaryStage;
        // Show the login screen
        this.userLogOutCallback();
        // Show the stage
        primaryStage.show();
    }

    protected void userLoginCallback(Personnel user) {
        // Get the scene size
        Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        // Create a FXML loader
        FXMLLoader loader = new FXMLLoader();
        // Set the location of the login view
		loader.setLocation(App.class.getClassLoader().getResource("view/RootView.fxml"));
        // Try loading the borderpane
        try {
            // Load the borderpane
            BorderPane rootView = (BorderPane) loader.load();
            // Set the scene
            this.weanStage.setScene(new Scene(rootView, screenSize.getWidth(), screenSize.getHeight()));
            // Get the controller
            RootCtrl rootCtrl = loader.getController();
            // Set the logout callback
            rootCtrl.setLogOutCallback(() -> {
                userLogOutCallback();
            });
            // Set the personnel
            rootCtrl.setPersonnel(user);
        } catch (IOException e) {
            System.err.println("Failed to display navigation screen.");
            e.printStackTrace();
        } catch (Exception e) {
            System.err.println("Unhandled exception.");
            e.printStackTrace();
        }
    }

    protected void userLogOutCallback() {
        // Get the scene size
        Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        // Create a FXML loader
        FXMLLoader loader = new FXMLLoader();
        // Set the location of the login view
		loader.setLocation(App.class.getClassLoader().getResource("view/LoginView.fxml"));
        // Try loading the borderpane
        try {
            // Load the borderpane
            BorderPane loginView = (BorderPane) loader.load();
            // Set the scene
            this.weanStage.setScene(new Scene(loginView, screenSize.getWidth(), screenSize.getHeight()));
            // Get the controller
            LoginCtrl loginCtrl = loader.getController();
            // Set the login callback
            loginCtrl.setLoginCallback((Personnel user) -> {
                userLoginCallback(user);
            });
        } catch (IOException e) {
            System.err.println("Failed to display login screen.");
            e.printStackTrace();
        } catch (Exception e) {
            System.err.println("Unhandled exception.");
            e.printStackTrace();
        }
    }
}
